# 201214 - JavaScript Day 12
## 복습 - Chapter 23. 실행 컨텍스트

- 소스코드가 로드되면 실제로는 window가 맨 처음에 존재
- 식별자가 등록이 되려면 실행 컨텍스트와 렉시컬 환경이 만들어져 있어야함
- 모든 실행 컨텍스트를 만드는 코드들은 렉시컬 환경을 가진다
- 렉시컬 환경은 스코프의 실체다 = 식별자들을 등록하는 곳이고 식별자와 바인딩된 값을 관리, 스코프체인으로 연결되어야 함(상위 스포크를 알고 있음- 외부 렉시컬 환경에 대한 참조)
- 실행 컨텍스트와 렉시컬 환경은 기본적으로 1:1 (아닌 경우도 있긴해)
- 렉시컬 환경은 두가지로
    - 환경 레코드
    - 외부 렉시컬 환경에 대한 참조
- 소스코드마다 환경 레코드의 구조가 다르다
- 전역 코드는 전역 객체와 연결되어 있어야 한다
- 전역 함수는 전역 객체의 메서드, var 전역 변수는 전역 객체의 프로퍼티
- ES5에서는 전역 스코프의 역할을 window가 했다
- 표준 빌트인 객체들, 호스트 객체들 다 window에 들어가 있음 그래서 전역 변수처럼 사용할 수 있었던 것임
- let, const는 window의 프로퍼티가 되지 않기 때문에 window 말고 다른 공간이 필요하게 되어 선언적 환경 레코드가 만들어짐
- Object Environment Record - bindingObject는 전역 객체를 가리킴 - 환경에 따라 참조값을 바꿔주기 위해.. 브라우저면 window지만 Node.js 환경은 또 다름 ?????????????????????
- 전역 실행 컨텍스트는 로드 되자마자 push됨 (평가단계에)
- 함수 실행 컨텍스트는 호출되자마자 push됨
- 식별자를 현재 실행중인 실컨의 렉시컬 환경에서 찾는다 - 실행 컨텍스트 스택을 보고 현재 실행중인 실행 컨텍스트를 알 수 있다
- arguments 객체 - 함수 몸체 내부에서 지역 변수처럼 사용할 수 있는 것
- 선언이란 실행 컨텍스트의 렉시컬 환경 레코드에 등록하는거
- break point - 버전업을  어쩌구 ..........??
    - 하위 호환을 어쩌구 해서 개발함
- 함수 환경 레코드에서는 전역 환경 레코드처럼 var와 let, const를 구분하여 저장하지 않음 (선언적 환경레코드, window로 구분 안함)
- 중첩 함수 호출했다고 외부 함수가 종료된것은 아님

- 함수 실행 종료  = 스코프가 사라진다
- 지역변수의 생명주기가 끝났다 - 함수의 종료와 함께
- 함수의 호출~함수 종료 = 지역 변수의 생명주기

- 실행 컨텍스트가 pop되면 렉시컬 환경과 환경 레코드를 바라보고 있는게 없어져서 순차적으로 날라가는거 .. 함께 셋이 셋트로 다 날라가는게 아니고
- 전역 실행 컨텍스트 다 날라가더라도... window는 안날라감 특이한 놈이라서 혼자서 살아남을 수 있음 - 자기 참조를 하고 있음 외딴섬
    - 기본적으로 외딴섬 - 둘이서만 바라보고 있으면(순환 참조) 가비지 컬렉터의 대상이 되지만.. window는 대상이 안됨
- 일반적으로 함수의 호출이 종료되면 실행 컨텍스트가 팝되고 그럼 렉시컬 환경도 사라짐
- 함수는 [[Environment]] 내부 슬롯을 통해 자기 상위 스코프(렉시컬 환경)를 기억한다 - 함수가 정의될때 실행중인 실행 컨텍스트의 렉시컬 환경

---

## Chapter 24. 클로저

- 함수가 종료했음해도 불구하고 그 함수의 렉시컬 환경이 살아있는 것 - 누군가가 그 함수의 렉시컬 환경을 바라보고 있을때 (참조하고 있을 때)
- 클로저는 사용할 일이 많음 - 코딩할때 ⇒ **단골 면접 질문**
- 클로저를 실컨의 관점으로 바라보면 이해하기 수월하다
- 클로저는 js의 용어(개념)가 아니고 함수형 프로그래밍 언어 - js는 멀티패러다임 언어이니까
- **일급 객체** 라는 개념이 존재해야 함수형 프로그래밍이 가능 → 이것의 가장 큰 특징이 클로저
- "클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다" 외워서 써먹자!!! 꺟하하하하
- 용어 노트에 정리를 해보자! 정의 해보자! - 표현식 , 값, 문 , 추상화 등
- 중첩함수를 왜 만들까요?
    - 예를 들어, 외부 함수가 하는 일 중 일부분을 추상화한 것 .... 모아둔것 - 재사용의 필요성이 있어서 (여러번 사용)
    - 어떤 일의 이름을 붙이고 싶어서 - 추상화 : 코드 이해가 쉽다
    - 외부에서 선언해서 써도 되겠지만.. 그렇게 되면 다른 아이들도 참조할 수 있게 되니까.. 그 변수(중첩 함수)를 외부 함수만 (그 안에서) 사용할려고!
    - 전제(약속)을 깔면... 깨지기 쉽다 그니까 전제를 안하는게 좋다 - 가능성을 좁혀라
    - 약속을 안하면 깨질 일이 없다
    - js에서 중첩함수는 클로저와 관계가 있다 - 클로저를 이용하기 위해 중첩 함수를 만들기도 한다
- 메모리 누수(memory leak) 할 일 다 했는데 메모리를 잡고 있는것 - 버그의 일종

### 클로저와 렉시컬 환경

- **함수가 함수를 반환**
    - 함수가 종료했음에도 렉시컬 환경이 살아있는 것처럼 동작한다
    - 중첩함수가 상위 스코프인 외부 함수보다 더 오래 살아남았기 때문
- 클로저의 조건 : 외부 함수보다 중첩함수가 더 오래 유지 되는 경우
    - 외부 함수 밖에서 중첩 함수를 호출하더라도 외부 함수의 지역 변수에 접근할 수 있는 것이 클로저
    - 클로저는 자신의 스코프 + 상위 스코프를 항상 기억하고 들고 다닌다
    - 중첩 함수가 살아있는 한 외부 함수의 스코프를 기억하고 있기 때문에 외부 함수의 렉시컬 환경이 사라지지 않음
- 함수는 스코프가 언제나 두개?
- 이론적으로 모든 함수는 다 클로저.. 상위 스코프를 기억하고 있으니까 environment에
- 클로저는 항상 외부 함수가 있어야하고 내부 함수가 있어야 해 (조건1)
    - 중첩함수가 외부 함수보다 오래 살아남아야해 → 이 경우는 외부 함수가 중첩 함수를 반환한 경우임
    - 클로저는 소멸한 외부 함수의 렉시컬 환경을 참조할 수 있다 → 자신의 스코프 뿐만이 아니고 외부 함수의 스포크를 참조할 수 있음
    - 외부 함수의 변수를 참조하고 있지 않으면 클로저 아님.. 외부 함수를 아무도 안보고 있으니까 있을 필요가 없음 - 상위 스코프의 렉시컬 환경을 소멸시켜 버림
- 외부 함수보다 오래 유지되는 중첩함수가 외부 함수의 식별자를 참조하는 경우 (조건2)
- 중첩 함수가 리턴되고 받아주는 변수가 있어야해

이해 안되면 걍 외워..

- 클로저는 중첩 함수가 상위 스코프의 식별자를 참조, 중첩 함수가 외부 함수보다 더 오래 유지되는 경우 한정

- 클로저는 자유변수만 기억함
- 자유변수 - 클로저 함수가 참조하고 있는 상위 스코프의 변수
- 자유 변수가 아닌 그 외 변수는 가비지 컬렉터의 대상이 됨?
- 기억해야할 변수를 기억하는 것이기 때문에 메모리 낭비라고 보기에는 어렵다... 그렇다면 클로저를 쓰지 말아야하는 것 아니냐 필요한 것을 기억할 뿐이다 필요치 않은 것은 기억하지 않음

### 클로저의 활용

- 상태변수...
- 클로저는 상태를 **안전**하게 변경하고 **유지**하기 위해 사용
- 클로저는 대부분 즉시함수로 감싸고 중첩함수를 반환하는 패턴 자유 변수는 즉시 실행함수의 렉시컬 환경에 선언
- 함수 두개를 리턴하려면 객체 또는 배열에 담아서 return해야하는데 배열보다는 객체가 가독성이 좋음
- 메서드 축약 표현은 call만 됨 non-constructor → 메서드도 상위 스코프를 가진다 함수니까!  ⇒ 함수 객체가 생성될때 실행중인 실행 컨텍스트의 렉시컬 환경이 상위 스코프임

- 메서드는 대부분 프로퍼티를 조작할 때 사용

```jsx

const counter = {
	num: 0,
	increase() {
		return ++this.num;
	},
	decrease() {
		return --this.num;
	}
};
// 이렇게 하면 num은 public해서 안전하지 않음
// 따라서 클로저를 사용

const counter = (function () {
	const num = 0;
	return {
		increase() {
			return ++this.num;
		},
		decrease() {
			return --this.num;
		}
	};
})();
```

- 전형적인 클로저 패턴 :  `즉시실행 함수` (- 하나의 렉시컬 환경을 만드려고) 만들고 (외부 함수 환경) → 중첩함수 리턴 , 중첩 함수 안에서 자유변수 하나를 참조하고 있으면 됑

### 캡슐화와 정보 은닉

- 클래스 기반 객체지향 언어 용어임 - 캡슐화
    - 프로퍼티와 메서드를 하나로 묶어두는 것
    - 함께 따라나오는 개념이 정보 은닉
    - 캡슐화를 하면서 정보은닉을 할수 있는 것
- 기본적으로 정보 은닉이 안됨 js는
    - ⇒ 클로저를 쓰라는 것
- 정보 은닉 - 프로그래밍 세상에서는 정보를 알면 많이 알수록 안좋앙 문제가 생겨버림
    - 객체들은 서로 연결이 되어야행 그렇게 해서 어플리케이션을 만들어가
    - 외부에서 알 필요 없는 것들은 애초에 공개하지 않는게 좋아
- `_age` : 언더바는 내부에서만 쓸거야 너넨 알 필요 없어 의미의 컨벤션

```jsx
function Person(name, age) {
  this.name = name; // public
  let _age = age;   // private

  // 인스턴스 메서드
  this.sayHi = function () {
    console.log(`Hi! My name is ${this.name}. I am ${_age}.`);
  };
}

const me = new Person('Lee', 20);
me.sayHi(); // Hi! My name is Lee. I am 20.
console.log(me.name); // Lee
console.log(me._age); // undefined

const you = new Person('Kim', 30);
you.sayHi(); // Hi! My name is Kim. I am 30.
console.log(you.name); // Kim
console.log(you._age); // undefined
```

내가 헷갈렸던 예제 

- 렉시컬 환경이 한번밖에 생성되지 않아서 _age를 모두가 공유하게 됨 - 프로토타입 메서드로 만들면
- 그래서.. 인스턴스 메서드를 쓸 수 밖에 없음.. 그래서 결국 정보 은닉을 할수 없다아!

### 자주 발생하는 실수

- 어느 책이든 다 나옴...ㅋ 면접관들도 다 알겠지이
- 왜 333이 나올까 ⇒ var로 선언된 i는 전역 변수..
    - funsction () {return i;} 의 상위 스코프는 누굴까! → 전역임
    - ⇒ 1,2,3 이 나오게 하려면 클로저.. 매개변수 id가 자유변수
    - → 렉시컬 환경도 3번 만들어짐
    - var를 let으로 바꾸기만 해도 완성! (var는 블록레벨 스코프를 만들지 않음)

        ⇒ 렉시컬 환경을 만든다 - 코드블록이! (실컨은 만들지 않음)

        → 렉시컬 환경을 for문을 도는 만큼 만들어버려 그리고 실컨의 화살표가  옮겨서 가리키다가 결국 끝에는 원래(전역 렉환)로 돌아옴

        → 앞에 만들어진 렉환을 상위 스코프로 연결 연결 → 전역 렉환까지 연결

        if문은 렉환이 한번 만들어지지만, for문은 도는 만큼

        → 블록문 안에 let이나 const가 선언되어 있으면 렉시컬 환경을 새롭게 만든다!!!!! ⇒ 중요쓰 (es5에는 없어 이런거) 

- 고차함수는 for문을 안씀.. for문을 추상화함 (대신 내부에서 돌려줌) 그러나 겉에서 보기엔 for문 아님.. ⇒ 배열에서 배울거야 , 머릿속으로 for문 돌려야해... 띠로린
    - for문 익숙해져야해...

---

전역 객체도 객체니까 누군가 만들었겠지 그러니 생성자 함수가 있을겨..  

---

## Chapter 클래스

- 클래스는 new를 빼고서는 호출할 수 없음 only constructor만 가지고 있고, 문법이 엄격함
- 클래스가 클래스를 상속받아 확장할 수 있음
- 강사님 개인적으로는 클래스 별로 안좋아함.. 더 복잡한 경우가 많음
- 실무에서 dom, event 중심으로 코딩하게 됨 view 중심으로 일하니까
    - 이때 class가 문제가 됨.. this 때문에?

```jsx
class Person {
	constructor(name) { // name이 인수
		this.name = name;
		// 인스턴스 메서드 만드려면 여기다가 this.sayHi = 
		// 근데 굳이 왜 이렇게 쓰냐 이거지 
	}
	// 기본 프로토타입 메서드, 메서드 축약 표현으로
	sayHi() { something }
}

const me = new Person ('Judy');
// new 안 붙이면 TypeError 발생 
me.sayHi();

console.log(typeof Person); // function , js의 클래스는 함수다
// 클래스가 평가되면 생성자 함수가 만들어진다 내부적으로

```

- 문법적 설탕? 동일한 기능을 하는 새로운 문법, 기존 문법이 복잡해서 만들어낸!
- 클래스는 새로운 객체 생성 방식의 하나로 보는거이 좋음 생성자함수의 문법적 설탕이 아니구
- 함수가 함수를 상속받음 인스턴스를 상속받는게 아니구 - extends