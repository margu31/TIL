## 문제풀이 
데이터가 바뀌면 재할당을 한다 ! accessor를 사용해라 
재할당이 이루어져야 하니까 let을 썼다 

- 현업에서는 기본적으로 for문을 쓴다는 생각을 버려라!
  - filter, reduce, map, forEach (forEach는 가장 마지막 최후의 수단으로 사용)
- 코드가 한국말로 술술 나오면서 해야해 코딩을 : 해석이 되어야 한다는거지 

```jsx
// 6번
function toggleCompletedById(id) {
  todos = todos.map (todo => todo.id === id ? { ...todo, completed: !todo.completed} : todo)
}
// map은 항상 배열을 리턴, filter도.. forEach는 항상 undefined 반환함
// 재할당!! 
// mutator말고 accessor 사용해보자~ 데이터 변경!
```

```jsx
// 7번
// let 사용 이유는 불변성을 유지하라는 것 
function toggleCompletedAll() {
  todos = todos.map(todo => ({...todo, completed: true}));
}
```

---

## Chapter 38. 브라우저의 렌더링 과정

- 파싱 : 문법에 맞춰 해석하는 과정
  - 토큰으로 일단 나눈다 (문은 토큰으로 이루어져 있다. 문은 명령의 한 단위) &#8594; 하나하나 의미가 있는 단위로 쪼갠다는 의미
  - 토큰의 문법적 의미와 구조를 반영해서 트리 구조의 자료 구조를 생성하는 과정이 `parsing`
- 루트 : 최상단이자 뿌리, 리프: 자식이 없어 
- 루트는 반드시 하나 
- `parse tree`
  - HTML은 DOM tree
  - CSS는 CSSOM tree
  - JS는 AST
- 트리 구조를 가지고 바이트 코드를 만들어서 실행
- js의 최종 목정은 컴퓨터에 일을 시키는 것
- html, css의 최종 목적은 **렌더링**! 브라우저에 뭔가를 그리는 것 
- 렌더링 : 다양한 의미를 가짐
  - 서버사이드냐 클라이언트 사이드냐
  - 브라우저에 시각적으로 출력하는거 

- 렌더링 과정
  - Load 서버사이드에 요청한 뒤 도착한 전기 신호(2진수 덩어리)를 받음
  - 그것을 해석하는게 파싱
  - 해석한 것들을 트리를 만들어줌  
  - css는 홀로 존재해서는 의미가 없음.. html이 존재해야 의미가 있음
  - 그래서 DOM과 CSSOM이 만나 하나로 합쳐짐 
  - DOM tree는 html 문서에 있는 것을 완전히 가지고 있음
  - DOM에다가 CSSOM을 가져와서 합치는거징 (DOM이 베이스)
  - 합쳐진 렌더 트리를 레이아웃 하고 페인팅(픽셀에 컬러 매기는것)
  - DOM트리가 느린 것이 아니라 렌더 트리 이후가 느린거임...ㅋ 레이아웃에 주의하자!!! (리플로우)
  - 레이아웃 변경은 가급적 안하는게 좋음 성능면에서 

- 게코(영어: Gecko)은 웹 브라우저를 만드는 데 기반을 제공하는 오픈 소스 응용 프로그램 프레임워크 (파이어폭스만)
- 그 외는 보통 웹킷(Webkit) 사용 

- js 렌더링
  - 로드 하고 parse 함
  - 전부 다 각각 parse 과정을 거치는 이유는 다 문법이 다르기 때문 
  - 파스 하는 애들이 parser 
  - 파싱 후 트리구조 만들어서 바이트 코드로 

- DOM안에 바꾸는게 있다? 
- 바뀌면 렌더 트리를 다시 만들어야함.. -> 브라우저가 힘두러행 ㅜㅜ 

### 요청과 응답
- 아주 기본적인거... 이거 모르면 프로그래머가 아니쥐 
- 클라이언트는 **요청**하는게 핵심 기능 - 클라이언트는 브라우저 
- 인터넷에 의해 연결되어있음 
- 서버의 핵심은 **응답**
- 요청과 응답은 쌍으로 이루어져있다 
- http의 기본
- frondend와 퍼블리셔와의 차이는 서버와의 통신(교류)을 할줄 아느냐 못하느냐가 가장 큰 차이 
- 규약(약속)이 프로토콜 &#8594; HTTP
- http를 쫘악 한번 훑어보면 좋음...(그림 있는걸로)

- url = uri &#8594; URI가 정식 명칭으로 요청에 대한 식별자를 의미 (i는 identify) 
- scheme(protocol) : 시큐어s가 붙어있기도 하고 안붙어있기도 하고 `http` or `https` (s는 좀더 보안측면에서 좋음) 
- `//` 그냥 구분자 .. 의미 no
- 도메인, 호스트 : 주소, 서버를 찾아갈 수 있는 식별자로 뭐라구..? 헷  
-  port는 왜 존재할까아.. 서버들을 구분할 수 있는 항구 같은 역할 &#8594; 호스트에 서버가 여러개일 수도 있으니까 
  - 항구에 배가 하나만 들어오는게 아니구 여러대가 들어올 수 있지요  
  - 8080 은 보통 웹서버  80, 8000도 많이 사용
- path 
  - root folder = 퍼블릭 
  - 루트 폴더를 기준으로 한 경로를 나타냄
  - rest API .. 자산의 이름으로 사용하게됨 
  - 중의적 의미를 가짐 원래는 루트폴더 기준의 경로를 나타냈었음 
  - `rest API` 가 대세이나 `graphQL`이란 것도 나옴 

- `?` 뒤에 키밸류의 형식이 한쌍 & 키밸류 &#8594; query or query string
- 서버가 받을 수 있는 문자 형식 get 방식 

- Ajax 이용하면 URL주소가 안 바뀌어서 (요청이 바뀌어도) SEO가 안좋음 
- 주소창
  - DNS 서버로 가서 주소를 주고 IP를 얻어옴 그럼 커넥션이 가능해짐 
  - 주소 뒤에 아무것도 요청값이 없으면 서버가 암묵적으로 뒤에 index.html 달라고 인식 &#8594; 루트요청 , 초기 요청
  - 초기(initial) 요청은 대부분 html임 그게 있어야 css도 js도 있으니까 

### http 버전
- http 3도 나왔으나 http2.0을 많이 씀

- http1.1
  - 1:1로 한쌍으로 요청과 응답이 이루어짐
  - 하나씩 하나씩 요청하고 응답받음

- http2.0
  - 초기요청은 하나만 한번만 날라감
  - 그 이후 요청은 복수로 한꺼번에 보내고 받을 수 있음 
  - 속도가 50% 빠름

### 렌더 트리 생성
- 노드는 하나하나의 객체를 말한다 
- 노드는 html 요소와 맵핑
- 레이아웃 프레싱이 일어났다 = 리플로우 : 레이아웃 계산을 다시 하는 것
- parcer의 종류가 굉장히 많음
- 상속 안되는 것들이 대부분 리플로우 발생 시킴

### js 파싱에 의한 html 파싱 중단

- script는 위치가 중요하다 그래서 보통 통상 바디태그 마지막에 쓰는게 안전하다 
- defer라는 어트리뷰트를 쓰면 위쪽에 위치시켜도 됨
- 나 돔 다 만들었어~ 하고 알려주는게 domcontentloaded 이벤트

---

## Chapter 39. DOM

- dom의 관점에서 얘기하자 frondend 니까 
- `<li>HTML</li>` &#8594; 노드 객체 
- 가장 루트 요소는 document -> 윈도우 객체에 달려있음
- dom에 접근하려면 항상 루트 요소부터, 그렇기 때문에 루트 요소가 진입점이다 
- text도 하나의 객체를 생성 
- 요소 노드에 접근하려면 css 선택자를 잘 알아야해 




