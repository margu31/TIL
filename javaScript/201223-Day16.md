# 201223 - JavaScript Day 16
## Chapter 31. 정규 표현식

- 정규 표현식이 무엇인지 개념을 익힌다
- 대략적으로 어떻게 쓰고 어떤 일을 하는지 알아보자 

### 정규 표현식이란?
- 문자열에 관한 것이다 (alt+f 해서 문자열 찾는 기능은 내부적으로 정규표현식으로..)
- 유효성 검사 할 때 사용 (Frontend)
- 정규표현식 객체! - 정규표현식 리터럴로 생성
- test 메서드에 검사하려는 문자열을 인수로 주면 target이 정규표현식 패턴과 매칭하는지 확인(테스트)
- 가독성이 별로... 

### 정규 표현식의 생성
- `/(pattern)/(flag)`
- 대부분 리터럴로 생성 (생성자 함수로 생성하는 건 특수할 때에만..)
- 플래그 i는 대소문자 구별 안함

### RegExp 메서드
- `.test`(사용빈도 높음), exec, match
- `.replace`(사용빈도 높음), search, split, match 문자열 객체가 지원하는 메서드
- .exec 잘 안쓰고.. `String.prototype.match`를 많이 씀
- `.test` : 매칭 여부 불리언 값으로 반환

### 플래그
- default 대소문자 구별
- i : 대소문자 구별하지 않겠다 
- g : 매칭되는거 모두 찾음
- m : 행이 바뀌었더라도 계속 검색
- i, g를 많이 씀

### 패턴
1. 문자열 검색
  - 기본적으로 따옴표 없이 씀
2. 임의의 문자열 검색
  - `/.../` 뭐든 상관없이 3자리 문자열이면 됨
  - 공백 문자도 하나의 문자열로 인정
3. 반복 검색
4. OR 검색
  - `\w` = word
  - `\d` = decimal
5. NOT 검색
  - `^` 대괄호 안에 있으면 Not, 밖에 있으면 Start 시작을 의미

### 자주 사용하는 정규표현식

- 패턴 안에 `/` 사용할 때에는 escape sequence로 역슬래시(`\`) 쳐줌 &#8594; 왜냐면~ 정규 표현식 시작, 끝에도 / 이거 있으니까 헷갈리지 않도록.. 끝맺음으로 인식하지 않게
```jsx
const url = 'https://example.com';

// 'http://' 또는 'https://'로 시작하는지 검사한다.
/^https?:\/\//.test(url); // -> true
```

5. 아이디로 사용 가능한지 검사!!! 
  
6. 메일 주소 형식에 맞는지 검사 &#8594; 많이 씀
  - 정식은 RFC 5322 규약에 맞춰... 그렇지만..잘 안씀 ㅎㅎ

회사가면 보통 정규표현식 모음집이 있을거야~
나만의 거 하나 있음 좋다? 이메일 주소 확인하는거 

- 한글 체크
```jsx
const korean = /[ㄱ-ㅎ|ㅏ-ㅣ|가-힣]/;
korean.test(string);

// | (Shift + \ ) = OR
```
---
## Chapter 32. String

`.replace`, `.split` 중요!!

- `replace` &#8594; 하나만 삭제 , 두 개 이상 다 바꾸고 싶으면 gi태그 붙여서 정규 표현식으로!
- `$&` &#8594; 캡쳐한다는 의미

```jsx
// 카멜 케이스를 스네이크 케이스로 변환하는 함수
function camelToSnake(camelCase) {
  // /.[A-Z]/g는 임의의 한 문자와 대문자로 이루어진 문자열에 매치한다.
  // 치환 함수의 인수로 매치 결과가 전달되고, 치환 함수가 반환한 결과와 매치 결과를 치환한다.
  // match 함수가 치환함수!!
  return camelCase.replace(/.[A-Z]/g, match => {
    console.log(match); // 'oW'
    return match[0] + '_' + match[1].toLowerCase();
  });
}

const camelCase = 'helloWorld';
camelToSnake(camelCase); // -> 'hello_world'

// 스네이크 케이스를 카멜 케이스로 변환하는 함수
function snakeToCamel(snakeCase) {
  // /_[a-z]/g는 _와 소문자로 이루어진 문자열에 매치한다.
  // 치환 함수의 인수로 매치 결과가 전달되고, 치환 함수가 반환한 결과와 매치 결과를 치환한다.
  return snakeCase.replace(/_[a-z]]/g, match => {
    console.log(match); // '_w'
    return match[1].toUpperCase();
  });
}

const snakeCase = 'hello_world';
snakeToCamel(snakeCase); // -> 'helloWorld'
```
- 치환 함수! 앞에 정규표현식과 매치된 친구를 넘겨줌

- `.split` &#8594; 되게 많이 씀!
  - 배열을 만들어 줌 
  - `' '` 스페이스 하나로 구분
  - `\s` 는 스페이스, 탭 등 모든 white space 전부~
  - `''` 한글자 한글자 다 구분
  - 인수 생략 : 배열로 담아버령
  - 두 번째 인수로 몇개 받을지 정해줌

---

## Chapter 35. 스프레드 문법
- 이터러블
  - 순회할 수 있는 자료구조 , for 문으로 돌수 있는 
  - 옛날에는 유사배열 객체라고 부름
  - 유사 배열 객체와 통합시키려는.... 
  - 배열, 문자열, Map, Set, Dom 컬렉션, arguments => 이터러블

- Symbol
  - 원시값
  - 서로 중복되지 않는 유일한 값
  - 상수 표현, 메서드 이름을 만들기 위한..
  - 앞으로 추가될 메서드 이름과 충돌되지 않게 하기 위해...

- 스프레드 문법
  - 객체를 복사 &#8594; 얕은 복사다!
  - 값이 아니기 때문에 문맥을 봐야한다! 변수에 할당할 수 없음
  - `,`로 이루어진 목록이 들어올 자리에서 사용
    1. 배열 리터럴 목록
    2. 함수 호출문 목록
    3. 객체 리터럴의 프로퍼티 목록

### 함수 호출문의 인수 목록에서 사용하는 경우 

`Math.max`는 정적 메서드이니까 this 안봐~
`call`은 전달할 인수들을 목록의 형태로 가짐
`apply`는 배열의 형태로 가짐
그리고 함수 호출되어서 인수들이 하나씩 넘어감???????

### 배열 리터럴 내부에서 사용하는 경우

1. concat
  - 배열을 이어붙인다 
  - push로 하면 배열로 쇽 들어옴 풀어지지않아(인수 자체가 요소로 그대로 들어감)
  ```jsx
  // ES5
  var arr = [1, 2].concat([3, 4]);
  console.log(arr); // [1, 2, 3, 4]
  // push 하면 [1,2,[3,4]]
  ```
  - 일단 빈 배열 만든다. 첫번째 아이를 풀어준다 뒤에도 풀어준다 &#8594; 새로운 배열 만든다 
  - 함수보다는 표현식으로 쓰는게 더 좋다!!

2. splice
  - 배열 중간에 삽입하거나 제거 
  - 풀어지지 않고 인수 자체로 그대로 들어감

### 객체 리터럴 내부에서 사용하는 경우
- 빈 객체를 만들고 얕은 복사 
  ```jsx
  const o1 = {x: 1, y: 2};
  const o2 = {y: 10, a: 3, b: 4};
  const merged = { ...o1, ...o2}

  // 중복되는 프로퍼티가 있으면 뒤에 있는게 앞에꺼를 덮어씀
  ```
- `Object.assign` 가변인자 함수 
  - 뒤에 있는 것부터 merge함 뒤에서 앞으로 (앞쪽이 base)
  - 뒤에 있는 객체가 앞에 꺼 덮어씀 , 중복 프로퍼티 있으면 
  - 빈 객체를 주면 새로운 객체를 생성하겠다 
  - 안주면 mutator 하겠다 뒤에있는 거를
  - 
- 그냥 스프레드를 쓰자아..

---

## Chapter 36. 디스트럭처링 할당
- 비구조화 할당
- 구조를 푼다
- 배열 / 객체 디스트럭처링 할당 두개로 나눠 생각

### 배열 디스트럭처링 할당
- const [one, two, three] 배열 리터럴 아님!! 3개의 변수를 선언하는거임
  ```jsx
  const arr = [1, 2, 3];
  const [one, two, three] = arr;
  ```
- 배열은 순서에 의미, 객체는 이름에 의미
- 배열 디스트럭처링 할당의 문법은 뒤에까지 꼭 써줘야해
  `const [x, y];` 만 쓰면 안됑 &#8594; 에러 발생! 할당까지 한큐에 써줘라
- 두번째 배열 안 받겠다는 의미
  `const [g, _, h] = [1, 2, 3];`
- 기본값 설정 가능 &#8594; 기본값보다 할당된 값이 더 우선됨

url 3개의 구성 요소 - ,,, 호스트(도메인) 프로토콜 패스?path

Rest 요소 -> Rest 파라미터와 유사 
가장 뒤에 사용 , 배열로 들어감

### 객체 디스트럭처링 할당
```jsx
const user = { firstName: 'judy', lastName: 'park' };
const { lastName, firstName } = user;
```
- 객체 디스트럭처링 할당은 할당까지 다 적어줘야함 안그러면 에러 

**중요한거**
const str = 'Hello';
const {length} = str;
  -> length라는 프로퍼티만 가져오겠다

유용한거 알아두랬는뎅...

- Rest 프로퍼티 
  - 나머지 아이들이 객체로 들어감

---

브라우저...
ECMAScript는 끝~~

## Chapter 38. 브라우저의 렌더링 과정 Preview

- 클라이언트 사이드 자바스크립트 또는 웹 API라고 부름
- 앞으로 실습할 때에는 브라우저에서 해야함.. 에디터에서는 안먹힘 nodejs환경에서 안됨

- 브라우저가 어떤식으로 랜더링을 하나 
- html, css를 화면에 어떻게 그리냐 -> 이것을 렌더링 한다 
- 면접에서 많이 물어봄 &#8594; 본인이 쓴 코드가 부하가 많이 걸리는지 아는지 모르는지 알기 위해 -> 90% 나옴
- 따라서 정확하게 개념 잡고 가는것이 중요 

- 소스코드는 전부 파일 형태로 저장
- 파일들의 최종 종착지는 서버 
- 작업 완료되면 전부 서버에 가서 동작을 한다 
- 브라우저가 클라이언트 - 사용자느 전부 브라우저를 통해 
- 브라우저가 요청을 함 서버는 요청받은거를 serve한다 

- 주소창이 요청을 하는곳.. 
- 도메인은 서버와 1:1 매핑
- 도메인만 있으면 안되고 뒤에 요청하는걸 적어줘야함 원래는 
- 메모리에 올려서.. 전기 신호로 바꾸고 랜선을 타고 보내는거 ... 클라이언트로
- 클라이언트는 그걸 받아서 다시 파일을 만들어 - 파싱해서 메모리에 올린다 
- 브라우저에게 다운되어진다 = 로드한다 
- 코드가 하나하나의 객체를 만든다...???
- 코드 전체를 도큐먼트 문서라고 부름 &#8594; 전부 해석해서 객체로 만든다 

- 정보와 구조를 가짐 html은 
  - 하나의 큰 자료구조에 모여있다 ... 
  - 이 자료구조가 dom 도큐먼트 오브젝트의 모델이다 

씨쏨?CSSOM -> css

- 돔이랑 CSSom을 합쳐서 렌더 트리란 자료구조 만들어서 그걸로 그린다 ...사이즈며 그런거 다 계산해서 레이아웃을 그리고 paint 함 
- 그럼 우리 눈에 보여진다... => 렌더링
- 레이아웃이랑 페인팅하는게 젤 어려움

- 리플로우 - 레이아웃 작업을 다시 시키는거 
- 리플로우를 발생시키는지 아닌지 알아야함 .. 돔에서 뭐 건드릴때 

- reflow를 최소화 시키는 코드를 짜야한다



