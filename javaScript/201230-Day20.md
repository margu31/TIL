# 201230 - JavaScript Day 20

## Chapter 40. 이벤트
- 뷰: 일반적으로 사용자가 보는 화면을 말한다
- 아벤트 핸들러는 함수! 이벤트 핸들러는 우리가 직접 호출할 수 없다 사용자의 액션이 언제 일어날지 우리가 알 수 없으니 호출하는 코드를 쓸 수 없다 
- 사용자의 액션이 이벤트 그것을 브라우저가 감지한다 
- 브라우저에 함수를 등록하고 이러한 이벤트가 있을 때 이 함수를 호출해줘 하는게 이벤트 핸들러 등록 
- window.onload -> 모든 게 다 로딩되면 로드 이벤트가 window에서 발생, 근데 느림 
- DOMContentLoaded -> dom 생성이 완료되었을 때! 로드 이벤트 발생이 좀 더 빠름 => addEventListener 함수로 사용해야함    
  `dovument.addEventListener('DOMContentLoaded',() => {something to do});`
- 캡쳐링을 잡는 경우는 별로 없음, 보통 대부분 버블링을 잡음
- DOM의 완성이란 건 없다.. 어디까지해야 완성인가? dom에 들어가면 바로 렌더링됨 js가 중간에 끼더라도 뒤에 있는것들은 지연이 될지 언정 앞에 있는 것은 뷰에 나타남
- 

3. addEventListener
실제로 이벤트를 발생시킨 요소 -> target

### 이벤트 전파

- 타겟을 클릭하면 윈도우부터 이벤트 객체가 타고 흘러내려와서 이벤트 타깃에 오면 다시 거슬러 올라감 
- 타깃으로 오는 방향은 캡쳐링, 타깃에서 가는건 버블링 단계 
- 버블링 페이지 또는 버블링 페이지 둘 중 하나만 잡음 (기본적으로 버블링 단계를 잡음) - 타깃을 제외하고는 둘다 오니까 캡쳐링도 버블링도 
- 이벤트 타깃의 부모(조상)요소들은 다 이벤트를 감지할 수 있다 따라서 부모요소에 이벤트 핸들러를 등록하면 다 감지할 수 있음 
- 뭐하면???? 필터링을 한번 해줘야해???????????? 왜?
- 이벤트 위임은 적극적으로 활용해야함

- 항상 서버를 생각해야한다 프론트엔드 개발자는

- checkbox 관련 이벤트 핸들러는 보통 change 이벤트 사용!

- rest api..? 
- 우리가 필요한건 배열이나 객체가 와야하는데 문자열로 옴 json이란게 오면 이걸 object로 변환하는 작업을 해야함
- 모델이란 것과 db와 일치해야함.. 
- 모델을 가지고 뷰를 만든다 
- 이벤트가 발생한것도 모델에 반영이 되어야함 그리고 서버 db와 일치되게끔 꾸준히 작업해줘야한다 
- 뷰와 모델의 중간에서 하는 애를 controler 
- mvc라는 모델 = 아주 전통적인 모델 

- module하면 전역 변수가 아니다...?
- fetch

- 뷰를 갱신해야한다 
- 클라이언트 사이드 렌더링 -> html 만들어서 dom에다가 추가하는 행동이 프론트엔드에서 말하는 렌더링

- 옵저브한다 = 관측한다


힝구힝구... ㅜㅜ




