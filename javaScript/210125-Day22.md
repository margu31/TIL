# 20210125 - JavaScript Day 22

## Chapter 41. 타이머
### 호출 스케줄링
- 미래에 호출되도록 한다 ex) 10초 후에 호출 스케줄링 하고 싶다면, 그 시간을 누가 재게 할 것인가  
  &#8594; 브라우저가 한다! why js엔진이 안할까? 
- js엔진은 실컨 스택이 한 개 즉, 스택에 push를 한번씩 밖에 못함 &#8594; 이것이 **싱글 스레드**
- js엔진은 한 번에 하나의 일 밖에 못 하기 때문에 js 엔진이 시간을 재게 되면 시간을 재는 동안 다른 일을 할 수 없다 &#8594; **블로킹 발생**
- 브라우저는 싱글 스레드가 아니고, 멀티 스레드 (js엔진 뿐만 아니라 렌더링 엔진 등 많음) - 따라서 지연이 발생하지 않음 

### 타이머 함수 
setTimeout / clearTimeout / setInterval / clearInterval

  `setTimeout` 
  - 콜백 함수를 전달 받음 (첫번째 인수)
  - 두번째 인수 시간(ms단위) 후에 콜백 함수를 호출하도록 **브라우저에 부탁**!
  - 호스트 객체 web API임 (Node.js에도 이런게 있음) - ECMAScript에 나오지 않음
  - 하는 일 : 브라우저에게 콜백 함수와 타이머를 알려줌 
  - 호출 스케줄링이 1회용 
  - `setInterval`을 하면 여러번 호출 가능 (타이머 간격으로)

  ```html
  <div class="disp">0</div>
  <button class="start">start</button>
  <button class="stop">stop</button>

  <script>
    let num = 0;
    let timerId = null;

    const $start = document.querySelector('.start');
    const $stop = document.querySelector('.stop');
    const $disp = document.querySelector('.disp');

    $start.onclick = () => {
      if (timerId)  return; // 이게 없으면 start를 두번 이상 누르면 setInterval이 복수로 생겨버림.. 그럼 num을 공유해서 더 빠르게 증가됨 또한 stop을 한번 누르면 제일 마지막에 생긴 inteval만 멈춤 
      
      timerId = setInterval(() => {
        num += 1;
        $disp.textContent = num;
      }, 100);
      
    };
    $stop.onclick = () => {
      clearInterval(timerId);
    };

  </script>

  ```


### 디바운스와 스로틀
....?
구현할 때 타이머 함수 사용

`디바운스(debounce)` - 일정 시간동안 동일한 이벤트가 연속적으로 발생할때 다 무시하고 마지막 이벤트만 처리
`스로틀(throttle)` - 일정 기간동안 무시하다가 일정 주기마다 이벤트 핸들러 호출

- 실무에서 사용할 때는 라이브러리를 사용해라!
- 마우스 이벤트나 그런거는 이거를 사용해라???????
- a태그 img 태그는 드래그앤드롭이 구현됨 

## Chapter 42. 비동기 프로그래밍
면접에서 많이 물어봄...... 모두들 어려워하기 때문에
퍼블과 개발자를 나누는 기준이 되기도 함

- **서버와의 통신이 비동기로 이루어짐**

- 서버에 데이터 요청 -> 답이 즉각 오지는 않음 물리적으로 떨어져있고 랜선으로 연결되어 있기 때문에 통신이 느리면 답이 느림.. 
- 요청한 데이터의 답이 늦게 오는 경우는, 데이터가 크거나, 서버 프로그램이 개판이거나, 서버가 망가졌을 경우 
- 통신 결과가 느리면 재방문률이 확 떨어져버림
- 기다리는 행동이 블로킹이다! &#8594; 블로킹이 발생하지 않게 하기 위함이 비동기 처리

1. 동기 처리 
  - 순서가 보장이 됨
   
- 스레드가 뭐냐? 동시에 일을 두 개 진행할 수 있는것 **병렬**로 처리할 수 있는것 
- 멀티 스레드의 문제는 같은 변수를 양쪽에서 바꿔버리면 .. 아주 짧은 타이밍 차이가 다른 결과를 만들어버리기 때문에 위험하다 
- 싱글 스레드!! 면접에 많이 나옴... 이거 나오면 비동기를 얘기하기 시작할거다 
- 블로킹되었다는 건 앞의 함수가 실행되는 동안 실행 못하고 기다리게 되는..

2. 비동기 처리
  - 블록킹이 발생하지 않도록 하는 것이 비동기 


sleep(foo, 3000)
bar()
커피가 나오는 것을 기다렸다가 자리에서 공부 bar - 순서 보장

setTimeout(foo, 3000)
bar()
커피가 나오는걸 기다리지 않고 공부 먼저 시작

커피 기다리는 벨 (신호) 이게 프로미스..?

### 이벤트 루프와 태스크 큐 
**이벤트 루프와 브라우저 환경** - 그림을 반드시 이해하고 그릴 수 있어야함..

- 타이머가 경과하면 이벤트가 발생하고 함수가 호출됨 (태스크 큐에 올라감), 태스크 큐(=이벤트 큐)는 선입선출
- 이벤트 루프 &#8594; 콜스택이 비어있는지 봄, 콜스택이 비어있으면 태스크 큐에 있는 가장 먼저 들어온 아이를 콜스택으로 보냄 (함수의 참조값, 주소값) &#8594; 그럼 실컨을 만든다
- 콜 스택이 비어있으려면 모든 전역 코드가 다 종료되어야 함
- 힙(heap)? 메모리 공간 

- `document.onclick = e => {};` &#8594; 이벤트가 발생하면 태스크 큐에 들어감 이는 우리가 호출하는게 아니고 브라우저가 호출하는 함수이니까 

동기 방식으로 작성된 코드가 비동기 코드보다 우선 순위를 갖는다 
콜백함수를 태스크 큐에 등록하는 건 브라우저의 역할
