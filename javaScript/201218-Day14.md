## Chapter 26. ES6 함수의 추가 기능

### 화살표 함수

- `this` 바인딩 없다 ! 그래서 참조하면 상위 스코프에서 this 를 찾음
- constructor가 아니다 → 프로토타입 객체도 안 만들고 함수객체가 갖는 프로토 프로퍼티도 없다? 몸이 가볍다 부수적인 행동 안해서 더 빨리 만들고 메모리 소비도 줄어듬

```jsx
const bar = () => () => console.log(this);

const bar = function () {
	return function () { console.log(this); }
}
```

- 메서드 축약 표현 : 메서드로서의 기능에 충실함 new로 호출 못행
- 모든 함수를 화살표 함수로 대체하는 것은 아니얌 - 일반 함수로서 호출이 되면 화살표함수를 써라
- 화살표 함수는 this가 없으니까 call 했을 때 호출은 되지만 this 교체는 무시됨
- 화살표 함수에서는 call, apply, bind 쓸 일이 없디
- 메서드가 들어올 자리에 화살표 함수가 들어오면 안됨다 this가 꼬이는 일이 생긴다
- 메서드 쓰이는 곳에는 메서드 축약 표현을 써라

```jsx
function Person(name) {
  this.name = name;
}

Person.prototype = {
  // constructor 프로퍼티와 생성자 함수 간의 연결을 재설정
  constructor: Person, // 얘를 빼먹으면 안돼
  sayHi() { console.log(`Hi ${this.name}`); }
};

const person = new Person('Lee');
person.sayHi(); // Hi Lee
```

- 코드 블록인지 아닌지 잘 봐야함.. 그래야 상위 스코프를 찾을 수 있음
- 클래스 {} 안에는 메서드들만 와야함

```jsx
// Bad
class Person { // <- 코드블록 아니고 객체 리터럴? 함수 리터럴?
  // 클래스 필드 정의 제안
  name = 'Lee';
  sayHi = () => console.log(`Hi ${this.name}`);
}

const person = new Person();
person.sayHi(); // Hi Lee
```

- this, super, new.target, arguments 다 없다
- `super`라는 것은 메서드만 써야하는것
- `arguments` 중요!
    - 모든 함수들이 함수 내부에서 식별자처럼 쓸 수 있는 것
    - arguments 대신에 화살표 함수에서는 가변인자 함수를 만들 때 Rest 파라미터 사용
    - arguments 유사 배열 객체 - 사용 방법이 배열 객체와 비슷하지만 배열과 다르게 메서드를 만들수 있음(자신의 메서드)
    - 많이 사용하지 않는 추세이다....
    - 이터러블.. 로 바뀜 ES6에서는

### Rest 파라미터

- 새로운 문법으로 등장~
- `...` 을 사용한다~ 호출하기 위해 식별자 붙여줌 뒤에 ex) rest

```jsx
function foo (...rest) {
	console.log(rest);
}

foo(1, 2, 3, 4, 5);
```

- 항상 매개변수 맨 뒤에 써줘야한다 아님 홀로 존재하든지~
- 항상 **'배열'**로 담긴다 - 배열이 가장 활용 빈도가 높아서
    - 배열이 너무나 너무나 너무나 중요
    - 유용한 메서드가 많은 것이 배열이다
- Rest 파라미터는 단 하나만 사용해준다

### Rest 파라미터 vs arguments 객체

- `Array.prototype.slice.call(arguments);` 일부를 덜어내는... 예전에는 이걸 그냥 외워서 씀
    - 전체를 슬라이스 해버림... 이건 결국 복사하는것 결론적으로
    - 뭘 배열로 바꿔주는..?

```jsx
// ES5 이전 문법
function sum() { // 여기에 ... 쓰면 풀어진 애들을 모은다
	const array = [...arguments]; // 스프레드 문법 , 모아진 것을 푼다

	return array.reduce(function (pre, cur) {
		return pre + cur;
	}, 0);
}

console.log(sum(1, 2, 3, 4, 5));	 

// ES6 문법
function sum(...args) {
  // Rest 파라미터 args에는 배열 [1, 2, 3, 4, 5]가 할당된다.
  return args.reduce((pre, cur) => pre + cur, 0);
}
console.log(sum(1, 2, 3, 4, 5)); // 15
```

- 모든 함수에서 쓸 수 있다 - Rest 파라미터
- 화살표 함수는 arguments 못 씀
- 가변인자함수 만들 때 화살표 함수는 방법이 rest파라미터 뿐, 그 외 함수는 rest파라미터 또는  arguments 둘 중 하나

### 매개변수 기본값

```jsx
function sum(x = 0, y = 0) { // 인수가 없으면 기본값으로 이걸 쓰겠다 
  return x + y;
}

console.log(sum(1, 2)); // 3
console.log(sum(1));    // 1

```

- 기본값으로 숫자 외 문자열, 함수도 넣어줄 수 있음
- REST파라미터에서는 기본값 지정할 수 없음

## Chapter 27. 배열

- 이거 잘 못 다루면 코딩을 잘 못하는 거랑 동일...
    - 배열을 잘 쓰려면 for문을 잘 써야함..
    - 순회하면서 하나씩 값을 꺼내온다는거니까 for문과 같이 생각해야함

### 배열이란?

- 배열은 자료 구조!
    - 모든 자료 구조의 베이스다
    - 활용 빈도 매우매우! 높아요!
- **순차적**이다
- 배열을 다루기 위한 메서드 다수 제공 - 이들을 잘 써야 코딩 스킬 up!
    - 이론만 알면 .. 문제가 있죠잉?
    - 이론은 코딩을 잘 하기 위해 배운거야
- 요소 - 배열에서만 쓰는 용어 아님
    - 배열을 만들어 내는 개별적인 존재들
    - 0개 이상의 요소가 모여 만들어진 자료구조가 배열
    - 요소에는 모든 값들이 올 수 있음. js에서 값으로 인정되는거
        - 배열, 함수, 객체, 원시값 등..
- 배열 안에 배열이 올 수 있음!
- 배열 안에 객체들이 여러개 들어있는 걸 많이 보게 될거임 실무에서
- 위치를 나타내는 값 = 인덱스 (0부터 시작)
- 요소에 접근하려면  `식별자인 배열의 이름[인덱스]`
- 순회한다 = 하나씩 들여다 본다 - 대표적인 방식은 for문
- const arr = [동일한 타입의 데이터를 갖는게 정석]
- 순차적으로 하나씩 동일한 행동을 할때 유용한 자료구조
- 배열의 핵심! `arr.length`
- typeof arr === object 배열은 객체
- 배열은 요소들의 집합 vs 객체는 프로퍼티 키와 프로퍼티 값
- 값의 순서에 의미가 있다
- 객체는 순회할 수 없는가..? ⇒ for...in문 사용 근데 잘 안사용 object.keys, entries, values 이런걸 사용.. 배열을 순회
- 값의 순서와 length 이게 명확히 차이가 난다 배열과 객체는
    - 이걸로 객체를 만들지 배열로 만들지 결정하면 됨

### 자바스크립트 배열은 배열이 아니다

- js의 배열은 배열이 아니다... (자료 구조 개념을 아는가, js를 어느정도 공부하였는가 확인하는 좋은 면접 질문)
    - 동일하지 않은 타입도 허용
    - 자료 구조에서 말하는 배열과는 다른 의미를 가진다
        - 그럼, 자료구조에서 배열은,
        - (전제) 메모리 공간의 크기가 동일한 사이즈를 가진다 , 밀집되어있다 연속적으로 다닥다닥 ⇒ 밀집 배열(dense array)
        - why  이런식으로 만드냐?
        - 모든 메모리 주소를 알고 있을 필요 없음 선두 메모리 주소를 가리키고 있음 → 붙어있으니까 메모리 주소 선두만 알고 있으면 인덱스로 잘 찾아 갈수 있음
        - 요소에 접근하는데 탁월한 성능 보유! 이길자가 없다! 젤 빠름!
        - 단점은, 새로운 요소를 추가하거나 삭제하면.. 진상이 따로 없음
            - 자리를 비우면 안되니까 계속 이동해야행.. 뿌잉
        - 요소의 삭제나 삽입이 빈번하게 밠생하지 않을 때 이걸써..
    - js 배열은 일반 객체... 다른 언어에서는 list라고 부르거나 함...
        - 동작은 비슷.. 자료구조에서 말하는 배열과
        - 어떨 땐 밀집 , 어떨 땐 밀집 아님..
        - 프로퍼티로 가지고 있다????? 인덱스가 프로퍼티 키
        - 일반 객체와 내부 구현은 다름.. 일반 객체처럼 보이지만
        - for문 돌릴때 일반 객체보다 훨~씬 빠름 내부 최적화 잘 되어 있음 .. 약 2배 빠름 → 최적화의 산물
    - 배열을 만들 때 동일한 데이터 타입의 요소를 나열하면 ⇒ 밀집 배열로 기본적으로 만듬
    - 문자열, 숫자 이런식으로 섞여있으면 ⇒ 밀집 배열 안됨.. 기본적으로 , 성능상 손해있을 수 있음
    - 밀집 배열을 만들기 위해 노력해야함.. 동일한 데이터 타입을 나열하기 위해 !
    - 기본적으로... 밀집 배열리 안되는 경우 많아 왜냐면~~ 객체로 요소들을 채우면.. 데이터 크기 다 달라요~ 다 같은 객체여도~
    - 그렇지만 가장 최악은.. 여긴 숫자 저기는 문자 ..
- 희소배열 → 밀집 배열의 반대
    - 다닥다닥 안붙어 있고 중간중간 공간이 있는거
    - js는 희소 배열이 가능... 그치만 이렇게 만들면 안돼! 안티 패턴~

    ```jsx
    const arr = [1, , 3];

    console.log(Object.getOwnPropertyDescriptors(arr));

    // 요소는 두개만 만들지만 length는 3
    // 따라서 for문 돌 때 세번 돌아버림
    ```

### length 프로퍼티와 희소 배열

- length 프로퍼티
    - 명시적으로 값을 할당 해줄 수도 있음.. 줄이는건 괜찮은데 늘리는게 문제!!!
    - 줄이는건 괜찮지만.. 늘리지는 말자 늘리면 기본적으로 희소 배열이 되어버려용 → 실제 length값과 안맞게 됨..?
    - 사실 줄이는 것도 안티 패턴이야...
    - 줄이고 싶으면.. 메서드를 써라 ! 임의의 값을 할당하지 말구
    - 걍 readonly로 생각해라

### 배열 생성

- 기본 리터럴로 배열 만들구용
- Array 생성자 함수 → 굉장히 설계가 안 좋다...
    - 좋은 함수란..?
        - 한가지 일만 하는 것 !!! 안에서 if문 쓰면 안좋은 함수
    - 인수에 따라 동작이 달라지므로.. array 생성자 함수로 만드는 것은 좋지 않다
    - 인수 하나만 숫자로 전달하면 그 숫자만큼의 희소 배열을 만들어 버림..  length로 봐가지구
    - 여러개 주면.. 요소들로 봄
    - 안쓰는게 좋아요~ Array 생성자 함수는~
    - 최대 개수 물리적인 한계가 있다 정도만 알아둬라 그렇게 쓸일도 없자노... 숫자에 집착 노노해~ rangeError
- `Array.of` , `Array.from` 아이들 쓸모 있음 새로운 아이들
    - 안에 들어오는 인수는 전부 요소로 본다
    - from은 유사배열 또는 이터러블을 인수로 주고 그것을 배열로 변환하여 반환
    - 스프레드 문법 대신에 Array.from을 쓰기도 한당..? 오디엥?? ㅋㅋㅋ 아까 뭐말했딩.. 애들을 풀어주기 위해서

    ```jsx
    Array.from({ length: 2, 0: 'a', 1: 'b' }); 

    // 이터러블 변환해주는 방법 두가지!!
    Array.from('Hello'); // -> ['H', 'e', 'l', 'l', 'o']
    [... 'Hello']; // -> ['H', 'e', 'l', 'l', 'o']
    ```

    ```jsx
    console.log(Array.from({ length: 5 }, (v, i) => i));
    // v에는 값이 넘어오고 i에는 인덱스 넘어옴, v는 생략하고 _이걸로 쓰는 경우 많음
    // 따라서 5번 호출됨 
    // [0, 1, 2, 3, 4]

    ```

### 배열 요소의 추가와 갱신

- 프로퍼티 추가는 안티 패턴

    ```jsx
    // 프로퍼티 추가
    arr['foo'] = 3;
    arr.bar = 4;
    arr[1.1] = 5;
    arr[-1] = 6;

    ```

### 배열 요소의 삭제

- 기본적으로 `delete` 연산자는 쓰지 않는다~ 희소배열 만들어버림..
    - 지우는건 나중에 배우는 메서드로

### 배열 메서드

- 배열도 객체이기 때문에 참조 타입? ????
- `mutator` 메서드 → 원본 배열을 직접 바꿔버림 ex) push

```jsx
const arr = [0];
arr.push(1); // 불변성 유지 안함 

console.log

// 불변성 유지 
```

- 배열 메서드 종류 2개
    - 직접 고치는 메서드 - `mutator` 불변성 유지 안함
    - 고치지 않고 결과 값을 반환하는 메서드 - `accessor` 불변성 유지
    - accessor가 기본적으로 좋지만 mutator가 성능은 좋음
- 비교적 최신에 도입된 메서드는 accessor로 설계, 그 이전은 대부분 mutator
    - 그렇다고 mutator 쓰지 말라는건 아니구, 원본이 바뀐다는 사실을 기억해라
1. Array.isArray
    - 정적 메서드
    - 인수로 배열을 줘야해

    ```jsx
    const a = [];

    // a.isArray(); 이런식으로 하면 안됩니당

    console.log(Array.isArray(a)); // true
    ```

2. Array.prototype.indexOf

    ```jsx
    const a = [1, 2, 3];

    arr.indexOf(2); // 이렇게 호출하세여 
    console.log(arr.indexOf(2)); // 1

    Array.prototype.indexOf(2); // 이렇게 하는거 아임당..

    const a = [1, 2, 2, 3];
    console.log(arr.indexOf(2)); // 1 앞에꺼 반환함
    ```

    - 특정 요소가 있는지 확인할 때 , 확인해서 없으면 추가하고 그런거 만들때 사용
    - `.includes` 포함되었니? 해서 Boolean 반환함
3. Array.prototype.push
    - 마지막 요소에 밀어 넣는거
    - mutator
    - ↔ 뒤에 있는걸 빼는건 pop - 어차피 맨 뒤에꺼 빼니까 인수 안줌 `arr.pop();`
    - 팝한걸 받고 싶으면 변수에 담아주고 변수 호출
- throw new TypeError 에러 발생 시키는거
- entries... 원본 복사???????

5. Array.prototype.unshift? shift??

- 그림을 보자.. push, pop, unshift, shift
- 요거 네가지 전부 mutator
- shift, unshift로는 queue 자료구조 만들수 있음
    - 아니다 push랑 shift로 하는건가?
- stak 자료구조는 pop, push로 만들고
- queue는 선입선출 first in first out → 은행 어플리케이션 대기표

7. concat ⇒ accessor 

- 이어붙인다
- 배열이 두개있는데 arr1을 앞에 인수로 arr2
    - 둘을 이어 붙인다
    - 인수로 배열 또는 일반 ㄱ숫자값 줄 수 있음
    - 일반 숫자 주면 push랑 비슷.. push는 result를 받아주지 않아도 됨?
- 원본 배열 안 바뀜
- 반드시 리턴값을 받아주는 변수가 있어야해
- concat은 인수가 ?풀어서 들어가고 push는 배열이 요소 하나로 들어가버림
- push로 하려면 .. 스프레드 문법으로 대체해서 사용 ... 써서 풀어줌
- 스프레드 문법 굉장히 유용

8. splice 

- slice랑 굉장히 헷갈려
- 중간에 새로운 요소를 밀어넣거나 제거할 때 사용
- mutator  리턴값은 제거한 아이들
- 인수 주는건 (시작할 인덱스, 제거할 개수, 채워넣을 아이들)
- 채워넣을 아이들 안써주면 그냥 제거만 한다~
- 제거 안하고 채우기만도 가능~ 개수에 0 써주면 됨

```jsx
// 이런 문제는 쉬운거다....

const arr = [1, 2, 3, 1, 2];

// 배열 array에서 item 요소를 제거한다. item 요소가 여러 개 존재하면 첫 번째 요소만 제거한다.
function remove(array, item) {
  // 제거할 item 요소의 인덱스를 취득한다.
  const index = array.indexOf(item);

  // 제거할 item 요소가 있다면 제거한다.
  if (index !== -1) array.splice(index, 1);

  return array;
}

console.log(remove(arr, 2)); // [1, 3, 1, 2]
console.log(remove(arr, 10)); // [1, 3, 1, 2]

// 2를 싹다 제거하는게 아니고 제일 먼저 만난 친구만 제거 
```

- filter → 다 지워 버림.. 그에 해당하는 요소를 싹 다

9. slice 복사해서 일부분 뜯어내는거 

- 원본 훼손 안함
- 복사해서 뜯어오는거 → 얕은 복사
- 첨부터 끝까지 slice하면 싹다 복사하는 것
- end 인덱스는 미포함..!!!!
- 음수인 경우 첫번째 인수가, 뒤에서부터
- 내용물은 같으나 배열은 별개임 → 얕은 복사?

10. join

- 요소들을 문자열로 이어 붙임 - 리턴값이 문자열
- 인수에 구분자를 주나봄 기본 default는 , 콤마
- 문자열을 배열로 할때에는 스프레드 문법 또는 array.from ?

11. reverse

- 역순으로 뒤집는것
- 원본 배열 변경됨

12. fill

- 채워~요소의 값을 싹다 채워라~
- 두번째 인수는 채우기 시작할 인텍스 전달 start index
- 세번째 인수는 채우기 중지할 인덱스 end index → 해당 인덱스 미포함!
- 한가지의 값으로만 채움...

13. includes

- 배열에 포함 여부 판단하여 boolean 반환
- linear search 가 indexOf와 비슷?

14. flat 

- 음청 최신 .. 작년에 나옴 ES10 - 최신 문법은 함수형 기법이 많음
- 배열 안에 배열이 들어있을 때 , 안에 있는 배열을 풀어줌 →평탄화
- 평탄화 레벨을 인수로 전달해서 결정할수 있음 → 기본값1
- 끝까지 풀고 싶다 몇단계든 → Infinity

### 배열 고차 함수

- 함수를 인수로서 전달 받거나 함수를 반환하는 함수를 고차함수라 함
- 콜백함수에 대한 개념이 불명확하면 어렵게 느껴짐..
- 고차함수(map)가 콜백함수를 인수를 전달하면서 호출... 인수 3개를 전달 v(요소값), i(인덱스), arr(얘자체)
    - arr의 개수만큼 map이 for문이 돌면서 콜백함수를 arr개수만큼 호출..

    ```jsx
    const arr = [1, 2, 3];

    arr.map((v, i, arr) => {}) // 리턴 반드시 해야함 새로운 배열이 반환..?

    // 1: v=1, i=0, arr=[1,2,3]
    // 2: v=2, i=1, arr=[1,2,3]
    // 3: v=2, i=2, arr=[1,2,3]

    const res = arr.map((v, i, arr) => {
    	return i;
    }
    console.log(res); // [0,1,2]

    ```

- 내부에서 for문을 돌아줌..

---

서버에서 배열로 정보를 담아서 주는 경우 많아... 이거를 받아서 html로 만들어서 렌더링 시키는게 우리 일..

함수를 익힌다는건.. 어떤걸 매개변수로 주고 어떤게 리턴되는지 알아야해 

이런 자료구조를 어떻게 컨트롤 하느냐.. 해서 알고리즘.. 

이터러블..?

---

의도적으로 써봐야함.. 안그럼 까먹는다규 

일단 가볍게 읽어보면서 이런게 있다~ 이런 빌트인 메서드가 있다~ 알자

시간과 끈기.... 

잠 충분히 자고 ... 매일 조금씩 많이 쳐보자아 

28~32 챕터는.. 강의 안해요.. 예습하고 모르는 것만 물어봐라..

