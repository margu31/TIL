# 201123 - JavaScript Day 4

## 조건문

### switch문

- switch문의 표현식은 문자열이나 숫자 타입인 경우가 많음
- if문과 다르게 조건식이 아니라 `표현식`이 들어간다!
- 폴스루(fall through)
    - switch문의 표현식의 평가 결과와 일치하는 case문으로 실행 흐름이 이동하여 문을 실행한 후 switch문을 탈출하지 않고 switch문이 끝날 때까지의 모든 case문과 default문을 실행하는 것 (break가 없기 때문)
    - break문을 생략한 폴스루가 유용한 경우도 있어서 일부러 이용하기도 함 (ex, 윤년 계산)
- default문에는 보통 break를 생략한다

## 반복문

### for문

> for (변수 선언문 또는 할당문; 조건식; 증감식) { 조건식이 참인 경우 반복 실행될 문; }

- 변수 선언문, 조건식, 증감식은 모두 옵션!
- 어떤 식도 선언하지 않으면 무한루프.. 개미지옥
- 조건식이 참(true)인 동안 반복 실행! 즉, 거짓으로 평가될 때까지 반복
- 선언문은 한 번만 실행!
- 변수 이름은 보통 `i`(iteration)를 많이 씀, 또 다른 변수가 필요할 때는 j, k 등을 사용

```jsx
for (var i = 0; i < 3; i++) {
	console.log(i); // 0,1,2
}

console.log(i);  // 3
```

- 증감식은 일반적으로 `i++` 을 사용한다
- `i++` 대신 `i += 1`로 표현도 가능하지만 일반적이지 않은 편
- for문은 대체로 몇 번 반복해야하는지 알 때 사용
- for문 한번 실행 → 선형 linear
- 2중 for문 → 면 , 매트릭스
- 3중 for문 → 입체 3차원 3D

- for문 등 반복문을 대체 하는것 foreach 메서드 등 많음
- for문 중요하지만.. 안 쓰는 편이 더 좋다..?

### while문

- 몇 번 반복해야하는지 불명확한 경우 사용
- for문으로도 만들어보고 while문도 만들어보고~

if문 뒤에 코드블럭 한줄이면 {}중괄호 생략 가능

### do...while문

- 코드블록 일단 1번은 실행
- 잘 사용하지 않는 듯..?

<쉬어가는 코너..>

효율보다는 정확성이 요구된다. 처음 만들 때부터 잘~ 만들어야 비용이 적게 든다.

왜냐면, 대충 실행되게끔 막 만들면 나중에 수정하는 비용이 더 들기 때문에.. 

서버와 클라이언트 얘기 나오구 프론트엔드가 주목받게 된 이유 등 좋은 말씀 많이 해주셨는데..ㅎ 기억이 안난다 메모할껄 그랬다!

### break문

- for in, for, for of, while, do while , switch문, 레이블문에서만 쓰임
- 레이블 문이란 식별자(이름)이 붙은 문
- switch문에서 case도 레이블 문임
- break 레이블문 이름; 하면 레이블문 코드 탈출

```jsx
// 문자열은 유사배열이므로 for 문으로 순회할 수 있다.
for (var i = 0; i < string.length; i++) {
  // 문자열의 개별 문자가 'l'이면
  if (string[i] === search) {
    index = i;
    break; // 반복문을 탈출한다.
  }
}

// if 문에서는 break 쓸수 없지만(syntaxError 발생) 위에꺼는 for 문을 탈출하는거라서 에러 안남
```

## 타입 변환과 단축 평가

### 타입 변환이란?

- 타입은 값에 대한 진술. 값이 타입을 가지고 있다
- 개발자가 의도적으로 타입을 변환하는 것을 명시적 타입 변환 또는 타입 캐스팅이라고 한다

### 암묵적 타입 변환

타입 변환을 해서 결과를 도출하지만 부수 효과는 없다!

```jsx
var x = '10'; var y = 2;

console.log (x+y) // '102'
console.log(x) // '10'
```

- `+` 연산자 쓸 때 주로 일어남 (문자열→숫자)

 ```jsx
 var x = '10';
 var y = +x; // 이때, +기호가 x값을 문자열이 아닌 숫자 타입으로 바꿔줌
 ```

- NOT연산자  
  `!!` ⇒ 불리언 값이 아닌 값을 불리언 값으로 바꿔주는 역할을 함

### 명시적 타입 변환

 - 숫자 및 불리언 타입 → 문자열 타입으로 변환  
   - `String( numner or boolean );` 이 방법은 비추!  
   - `( number or boolean ).toString( );` 이 방법도 비추..!  
   - `추천` 문자열 연결 연산자(`+`) 이용! - 표현력을 높이기 위해! 그리고 보기 편하잖아~ 짧고!
 - 숫자 타입으로 변환 추천 방법  
   - `+` 단항 산술 연산자 이용
   - 불리언 타입으로 변환 추천 방법  
   - 부정 논리 연산자 두번 사용 → `!!`

 >   Falsy 값  
     - `false`   
     - `undefined`   
     - `0` , `-0`   
     - `null`   
     - `NaN`   
     - `빈 문자열`   

### 단축 평가

js에만 있는게 아니고 웬만한 언어에는 다 있는 개념이다 ! 다만, js가 많이 활용한다

 - 논리연산자 ( `&&` , `||` )
   - 한쪽만 봐도 평가될수 있는거
   - 단축 평가를 사용하면 if문을 대체 할수 있다. 물론 삼항 조건 연산자도 사용 가능한데 미묘하게 다름
   - 삼항 조건 연산자는 if else문의 축약
   - 단축평가는 if문의 축약

  ```jsx
  message = done && '완료';
  console.log(message);

  // 완료가 들어왔냐 안들어왔냐에만 관심있을 때 써라 
  // 아니면 삼항조건 연산자 써도 되궁 (리액트 조건부 렌더링에서 나올 예정..)
  ```

 - 단축 평가 왜 쓸까?
   - 에러 발생을 방지하기 위해
    ```jsx
    var elem = null;
    var value = elem && elem.value; // -> 안전장치

    // elem이 false면 elem.value를 하지 않겠다(elem으로 평가)
    // elem이 true면 elem.value로 실행하겠다 
    // 이를 '방어 코드'라고 함, 많이 쓰임
    ```
   - 매개변수 기본값 설정
    ```jsx
    function getStringLength(str) { 
    	str = str || ' ' ;  // → 기본값을 갖게함
    	return str.length; 
    }
    ```

    뭔지 잘 모르겠군... 복습 필요.. (밑에 옵셔널, null 병합도..)

### 옵셔널 체이닝 연산자 ( `?.` )
 - 올해 6월에 추가된 따끈한 기술!
 - 좌항의 피연산자가 null 또는 undefined이면 undefined를 반환, 그렇지 않으면 우항의 프로퍼티를 참조
 - 변수가 null 또는 undefined인지 확인할 때 쓰나보당
  ```jsx
  var value = elem && elem.value; // (null할당)

    // 이거의 대용품이 

  var value = elem?.value; // (undifined 할당)
  ```

### null 병합 연산자 ( `??` )
 - 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환, 그렇지 않으면 좌항의 피연산자를 반환
 - 변수에 기본값을 설정할 때 유용

  ```jsx
  var foo = null ?? 'default string';
  console.log(foo);
  ```

---

## 객체 리터럴
### 객체란?
 > 인식의 대상이 되는 모두 다 object (객체)  
   프로그래머가 subject (주체)

- 0개 이상의 프로퍼티의 집합으로 이루어진게 객체다
- 행위를 나타내는 메서드와 현재의 상태를 나타내는 프로퍼티 값(데이터)
- 현재의 상태(property value)는 바뀔 수 있음
- 객체 안의 프로퍼티 값으로 함수도 넣어줄 수 있다.
- 객체 안의 행동을 하는 함수 프로퍼티를 `메서드`라고 함 → 즉, 메서드도 결국 프로퍼티
- js는 `멀티 패러다임 언어`
   - 객체 지향, 절차 지향, 함수 지향 모두 포함
   - java는 객체 지향 언어, C는 클래스 기반 절차 지향 패러다임

### 프로퍼티

- 선언되지 않은 key를 참조하면 undefined 반환
- 프로퍼티 값은 재할당 가능하다 (갱신)
- 선언되지 않은? property key를 만들어서 선언하면 프로퍼티가 만들어진다 → `프로퍼티의 동적 추가`
- 처음에 만들지 않았어도 property를 추가 할 수 있는 편리함!

```jsx
var person = {
  name: 'Park',
  age: 21
};

person.address = 'Seoul';

console.log(person); // {name: "Park", age: 21, address: "Seoul"}  
```

- 약속된 기호 안의 내용으로 (ex, var person { } ) js엔진이 객체를 만들어 줌 - 대부분의 언어는 리터럴로 객체를 만들어주지 않음
- 객체 지향 언어? 클래스 기반 언어?는 보통 '붕어빵 틀 → 붕어빵(클래스) → 인스턴스' 가 필요함.. 이게 있어야 객체를 만들어준다  
따라서, 한 번 붕어빵 틀을 만들면 그 모양의 붕어빵 말고는 만들수 없다. 즉, 변형 불가!
- js는 그런거 필요없고 뽷! 객체를 만들어 주고 동적 추가도 가능하다

- 프로퍼티 키는 변수아님(식별자아님) 따라서 식별자 명명규칙을 따라도 되고 안따라도 됨 - 그치만 지키는게 좋겠지요
- 식별자 명명 규칙을 준수하지 않은 이름은 따옴표로 감싸줘야함
- 프로퍼티 키는 순수한 문자열이다 근데 식별자 명명 규칙을 준수한 이름은 따옴표 생략 가능

### 프로퍼티 접근

- 식별자 명명 규칙을 지키지 않은 프로퍼티 키는 호출할때 . 을 사용하지 못하고 [ ] 대괄호를 사용해야함 대괄호 안에는 따옴표 표기해야해! 문자열!! - ex) `person.age`   , `person['first-name']`
- 웬만하면 그냥 규칙에 따라 이름 지어라

### 프로퍼티 삭제

- `delete` 연산자 사용 - 부수효과있음
- 사용법 : `delete + 참조값` ex) `delete person.firstName;`
- 굳이 지우려고 하지마! 이것은 `anti pattern` 이다 (하지 않았으면 좋겠다는 의미)
- anti pattern 의 대표적인 아이가 `delete` !!사용 금지라고 알아두자. 쓸 일 없음
- delete를 사용하면 js엔진이 힘들어 한다. 있다 없다 하니까 헷갈림
- 프로퍼티를 지우지 말고 그냥 소멸시켜버려!

## 객체 리터럴 확장 기능

### 프로퍼티 축약 표현

중요함!!!  
프로퍼티 키와 값이 동일하면 한번만 쓰면 됨

### 계산된 프로퍼티 이름

- `계산된 프로퍼티 키` 라고 사용하자
- 프로퍼티 키를 동적으로 만들어냄
- es5에서는 객체 리터럴 밖에서만 할 수 있었는데 es6에서는 내부에서 가능
- 대괄호 잊지마욤

### 메서드 축약 표현
es6문법이 심플하지용 

`sayHi: function() 또는 sayHi()` 

근데 내부 동작이 조금 다름.. 나중에 살펴보자 

---

## H.W

12 함수 예습.......최고 중요함....   
콜백함수... 젤 어렵고 젤 중요