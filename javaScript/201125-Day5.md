# 201126 - JavaScript Day 5
## 원시값과 객체의 비교

### 원시값

1. 변경 불가능한 값
   - 변수값 ! == 원시값
   - 원시 타입(primitive type)의 값, 즉 원시값은 `변경 불가능한 값(immutable value)`
   - 읽기 전용(read ONLY)
   - '키워드'란 명령어다
   - 변수값을 변경한다는 것과 원시값은 다른 얘기! 구분하자! ( 변수값은 바꿀 수 있으나 원시값은 바꿀 수 없다. )
   - 원시값의 경우 `재할당` 없이는 값을 바꿀 수 없다 주소가 바뀜(다른 공간 메모리)

2. 문자열과 불변성

   - 문자열은 원시값이므로 인덱스 배열로 (like `string[0] = 'S'` ) 특정 문자를 바꾸려고 시도해도 바뀌지 않고 무시된다.
   - 문자열은 유사 배열 객체로 `length` 프로퍼티를 가지고 있음 → 이로인해 for문에서 몇 번 반복할지 지정할 수 있음

3. 값에 의한 전달

```jsx
var score = 80;
var copy = score; // 여기서 score와 80은 동치!

console.log(score); // 80
console.log(copy); //80 
// 위에서 score와 copy의 값은 동일하지만, (평가된 값이 동일한 것)
// 실제로는 별개의 값이다 (차지하고 있는 메모리 공간이 다름)
// 따라서 서로 영향을 받지 않는다.

score = 100; // 재할당

console.log(score); // 100
console.log(copy); // 80 (재할당 된 score에 영향을 받지 않기 때문에 처음 할당된 score=80값이 그대로)

```

### 객체

- 객체 안에 들어있는 프로퍼티에 따라 차지하는 메모리 공간의 크기가 달라짐
- 따라서 메모리 공간을 많이 차지할 수도 있음
- js는 객체 지향 언어인데 클래스 기반이 아니고 `프로토 타입` 기반의 객체 지향 언어이다
- 객체는 크기가 크기 때문에 원시값처럼 복사해오면 메모리 낭비가 심할것
- 객체는 재할당 없이 값을 변경할수 있음 (주소값 그대로)
1. 변경 가능한 값
   - 객체는 할당 직전에 만들어지는데 할당 전, '유효한 식별자인지 확인 → 값을 만들고 → 할당'
   - 할당 = 바인딩한다  
    `name binding` - 식별자를 묶는다!

2. 참조에 의한 전달
   - 참조값 ?   
`point` : 실제 값이 들어있는 메모리 주소를 가지고 있음

```jsx
var person = {
	name: 'Lee'
};

person = {
	name: 'Kim'
};

console.log(person); // {name: 'Kim'}

// 위와 같이 프로퍼티를 재할당하면 새로운 객체를 만들어 버림
// 즉, 위의 person과 아래의 person은 다른 객체임(메모리 주소 다름)

var person2 = {
	name: 'Lee'
};

person2.name = 'Kim'; 
// 이런식으로 갱신(수정)을 해줘라! 
//이 때 메모리 주소가 바뀌지 않고 안의 내용물만 체인지
```

```jsx
var person {
	name: 'Lee'
};

var copy = person; // 참조값 복사(전달)
// copy와 person은 같은 메모리 주소(실제 값이 들어있는)를 공유하게 됨
// 두 식별자가 하나의 객체를 공유하기 때문에 서로 영향을 미치게 된다
// 한 쪽에서 값을 변경해버리면 다른 쪽에서 값을 불러올 때에도 변경된 값이 불러와짐
// 부작용이다..

copy.name = 'Kim';
console.log(person); // {name: "Kim"}
```

- 객체는 `메모리 주소`가 중요!!
따라서 일치연산자로 비교할 때에 주소도 비교함 (주소가 결국 값이니까!)

```jsx
var person1 = {
	name: 'Park' 
};
var person1 = {
	name: 'Park'
};

person1 === person2 // false (두 개의 메모리 주소 다름)
person1.name === person2.name // true
```

- 객체 불변성을 유지해라..?
    - ex) 값을 바꿀 때 `state.name = 'Kim'` 으로 바꾸지 말고 새로 할당해라! `state = { name: 'Kim' };`
    - but, 많은 프로퍼티를 가진 객체일 경우, 위에처럼 바꾸기는 힘들고.. 객체를 복사해서 복사한 값에서 수정해라!
    - 메모리 주소가 바뀌면 상태가 바뀐다 (??)

3. 깊은 복사 vs 얕은 복사

  - 얕은 복사(shallow copy)는 최상위 레벨의 객체만 복사하고 한 단계까지만 복사한다
  - 깊은 복사(deep copy) ? 객체에 중첩되어 있는 객체까지 몽~땅! 복사함
      - 깊은 복사를 해야 불변성 유지 가능!
      - 그렇지만.. 퍼포먼스 문제가 있다 (성능 저하)
      - 라이브러리 사용을 추천함~
  - 디스트럭처팅..? destructuring..?  
  일단은 넘어간다.. 후

---

## 함수

### 함수란?

- input process output
- input - 외부 값이 안으로 들어옴
- 입력을 받아 내부에서 미리 정의된 행동을 하고 출력해서 내보냄
- 일련의 과정을 문(statement)으로 구현하고 코드 블록을 감싸서 하나의 실행 단위로 정의한 것!!
- 함수는 `호출(function call/invoke)` 하지 않으면 실행 X
- input값을 받아주는 역할인 `매개변수(parameter, 인자)` , input(입력)을 `인수(argument)` , 출력(output)을 `반환값(return value)` 라고 함
- 인수에는 순서가 있다!
- 파라미터(매개변수)는 변수의 일종이므로 앞에 var가 생략된 것
- 함수는 제어문처럼 실행 순서가 뒤틀린다  
why? 호출되면 함수가 정의된 곳으로 올라가서 실행하니까

### 함수의 사용 이유

- `재사용`
- 중복 제거
- 하는 일 명확
- 가독성 Good
- 유지보수 Good → 수정할 때 편리, 실수도 적고 시간도 적게 걸림
- 함수 이름은 보통 명령형(동사)
- 함수가 외부에 영향을 안 주면 Best
- 함수형 패러다임 - 함수는 객체다! typeof 함수 ⇒ 'function' (object로 안나온다!)

### 함수 리터럴

- 표현식이 아닌 문에는 ; 세미콜론 안붙음

```jsx
var f = function add(x, y) {
	return x + y;
};
// 함수 리터럴을 값으로 봐야하니까 ; 세미콜론 붙음
// (x, y) 매개변수 목록
```

- 함수 이름
    - 함수 몸체 안에서만 유효
    - 즉 함수 스코프가 그 안에서만 유효하다는 의미
    - 함수 이름 옵션! 이름 생략 가능
- 매개변수 목록
    - 순서에 의미가 있음
    - 3개 정도까지만...
    - 매개변수의 스코프는 해당 함수 내부
- 프로퍼티는 식별자가 아니고 식별자 역할을 할 뿐..
- 함수 몸체
    - 호출됐을 때 실행
- 함수 vs 일반 객체
    - 함수 객체는 호출할 수 있으나 일반 객체는 호출할 수 없음
- 함수형 프로그래밍을 할 수 없는건 함수가 객체가 아님
- 함수가 객체인 언어는 함수형 프로그래밍이 가능
- 함수는 일급객체이다! (면접에서 많이 나옴 알아두자 일급객체가 뭔지)

### 함수 정의

- 함수를 호출하기 이전에 만들어야함

 1. 함수 선언문

- 표현식이 아닌 문
- 값으로 평가될 수가 없다
- 함수 이름이 꼭 있어야해! (생략 불가)
- 단독으로 존재하면 선언문
- 객체 리터럴과 비슷
- 런타임 이전에 함수 객체가 만들어짐
- 함수 호이스팅으로 인해 선언문 이전에 호출해도 실행됨
- 함수 호이스팅 vs 변수 호이스팅
    - 변수 호이스팅 : 선언문이 끌어올려지지만 할당은 이뤄지지 않아 할당문 전에 출력하면 undefined 반환
    - 함수 호이스팅 : 함수 정의가 runtime 이전에 실행된다! 함수 선언문도 runtime 이전에!!  
    또한, js엔진이 함수 이름을 가지고 식별자 이름을 암묵적으로 생성하여 할당까지 미리 다 runtime 이전에 끝내버림! → 따라서 실행까지 될 수 있는것
    - 함수 이름은 함수 내부에서만 호출 가능하니까, 동일 이름으로 식별자를 만들어 줌 → 외부에서도 호출 가능

2. 함수 표현식

- 함수 이름 있어도 되고 없어도 되고
- 값이 올 수 있는 곳에 위치
- 런타임 중에 할당될 때 함수가 만들어짐
- 따라서 호이스팅이 일어나지만 변수처럼 undefined 반환 (함수 호이스팅이 아니라 변수 호이스팅)

3. Function 생성자 함수

- 이거는 쓸 일 없음..

4. 화살표 함수 (중요)

- 쓸 데 없는 일 안함 시킨일만 하는건가봄?

`중의적 표현` 

- AST Ecplorer 사이트 참조하자
- `{}` 블록문 또는 표현식(객체 리터럴)로 해석
- `()` 앞 쪽에 식별자가 오면 함수 호출, 단독으로 사용되는 경우 그룹 연산자

### 함수 호출

1. 매개변수와 인수
- 가변 매개변수 ..? 생략하구 인수값을 확인하기위해 `arguments`로 확인
- "arguments" 객체 - 유사배열객체
- length라는 프로퍼티를 가짐 - 유사배열객체
- 인수가 할당되지 않은 매개변수의 값은 undefined (변수와 동일)

```jsx
function sum() {
  var add = 0;
  for (var i = 0; i < arguments.length; i++) {
    add += arguments[i];
  }
  return add;
}
console.log(sum(1, 2, 3, 4, 5)); // 15
```

---

### H.W

예습 13, 14